[{"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/index.js":"1","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/reportWebVitals.js":"2","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable1.js":"3","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/App.js":"4","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/data.js":"5","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/NumberRangeColumnFilter.js":"6","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/SelectColumnFilter.js":"7","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/customFilterTypes.js":"8","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable2.js":"9","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/CheckboxSelection.js":"10","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable3.js":"11","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable4.js":"12","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/Styles.js":"13","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/GlobalSearchFilter.js":"14","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/Pagination.js":"15","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TableShowHideColumns.js":"16","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/index.js":"17","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/data.js":"18","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/options/columns.js":"19","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/index.js":"20","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/options/filterTypes.js":"21","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TablePagination.js":"22","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TableDebugVals.js":"23","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TableAppliedFilters.js":"24"},{"size":500,"mtime":1608548282182,"results":"25","hashOfConfig":"26"},{"size":362,"mtime":1608547427832,"results":"27","hashOfConfig":"26"},{"size":7593,"mtime":1608558009775,"results":"28","hashOfConfig":"26"},{"size":660,"mtime":1610319050797,"results":"29","hashOfConfig":"26"},{"size":193,"mtime":1608553503167,"results":"30","hashOfConfig":"26"},{"size":1550,"mtime":1608548783452,"results":"31","hashOfConfig":"26"},{"size":849,"mtime":1608549006395,"results":"32","hashOfConfig":"26"},{"size":862,"mtime":1608549661576,"results":"33","hashOfConfig":"26"},{"size":8876,"mtime":1608558024869,"results":"34","hashOfConfig":"26"},{"size":1317,"mtime":1608551710573,"results":"35","hashOfConfig":"26"},{"size":8978,"mtime":1608558036948,"results":"36","hashOfConfig":"26"},{"size":9422,"mtime":1610316360523,"results":"37","hashOfConfig":"26"},{"size":756,"mtime":1608568954629,"results":"38","hashOfConfig":"26"},{"size":706,"mtime":1608569135585,"results":"39","hashOfConfig":"26"},{"size":1479,"mtime":1608553161272,"results":"40","hashOfConfig":"26"},{"size":1228,"mtime":1610317805916,"results":"41","hashOfConfig":"26"},{"size":1754,"mtime":1610317250598,"results":"42","hashOfConfig":"26"},{"size":2502,"mtime":1610316829427,"results":"43","hashOfConfig":"26"},{"size":1178,"mtime":1610317035894,"results":"44","hashOfConfig":"26"},{"size":3339,"mtime":1610319009113,"results":"45","hashOfConfig":"26"},{"size":1376,"mtime":1610316548786,"results":"46","hashOfConfig":"26"},{"size":1483,"mtime":1610316880306,"results":"47","hashOfConfig":"26"},{"size":595,"mtime":1610314548869,"results":"48","hashOfConfig":"26"},{"size":766,"mtime":1610319111115,"results":"49","hashOfConfig":"26"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},"7w60ns",{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"59"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"66"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"102","messages":"103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"104","messages":"105","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/index.js",[],["106","107"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/reportWebVitals.js",[],["108","109"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable1.js",["110","111"],"import React from \"react\";\n\nimport {\n  useTable,\n  usePagination,\n  useSortBy,\n  useFilters,\n  useExpanded,\n  useRowSelect,\n} from \"react-table\";\n\nimport { tableData, tableData1 } from \"../data\";\nimport customFilterTypes from \"../filters/customFilterTypes\";\nimport NumberRangeColumnFilter from \"../filters/NumberRangeColumnFilter\";\nimport SelectColumnFilter from \"../filters/SelectColumnFilter\";\nimport DefaultColumnFilter from \"../filters/DefaultColumnFilter\";\nimport EditableCell from \"../components/EditableCell\";\nimport { useCheckboxSelection } from \"../components/CheckboxSelection\";\nimport Pagination from \"../components/Pagination\";\n\nimport Styles from \"../Styles\";\n\nconst defaultColumnConfig = () => ({\n  Filter: DefaultColumnFilter,\n  Cell: EditableCell,\n});\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction Table({\n  columns,\n  data,\n  updateMyData,\n  skipReset,\n  filterTypes,\n  defaultColumn,\n}) {\n  // Use the state and functions returned from useTable to build your UI\n  const {\n    getTableProps,\n    getTableBodyProps,\n    headerGroups,\n    prepareRow,\n    page, // Instead of using 'rows', we'll use page,\n    // which has only the rows for the active page\n\n    // The rest of these things are super handy, too ;)\n    canPreviousPage,\n    canNextPage,\n    pageOptions,\n    pageCount,\n    gotoPage,\n    nextPage,\n    previousPage,\n    setPageSize,\n    state: { pageIndex, pageSize, sortBy, expanded, filters, selectedRowIds },\n  } = useTable(\n    {\n      columns,\n      data,\n      defaultColumn,\n      filterTypes,\n      // updateMyData isn't part of the API, but anything we put into these options will automatically be available on the instance.\n      // That way we can call this function from our cell renderer!\n      updateMyData,\n      // We also need to pass this so the page doesn't change\n      // when we edit the data.\n      autoResetPage: !skipReset,\n      autoResetSelectedRows: !skipReset,\n      disableMultiSort: true,\n    },\n    useFilters,\n    useSortBy,\n    useExpanded,\n    usePagination,\n    useRowSelect,\n    // Here we will use a plugin to add our selection column\n    useCheckboxSelection\n  );\n\n  // Render the UI for your table\n  return (\n    <>\n      <table {...getTableProps()}>\n        <thead>\n          {headerGroups.map((headerGroup) => (\n            <tr {...headerGroup.getHeaderGroupProps()}>\n              {headerGroup.headers.map((column) => (\n                <th {...column.getHeaderProps()}>\n                  <div>\n                    <span {...column.getSortByToggleProps()}>\n                      {column.render(\"Header\")}\n                      {/* Add a sort direction indicator */}\n                      {column.isSorted\n                        ? column.isSortedDesc\n                          ? \" 🔽\"\n                          : \" 🔼\"\n                        : \"\"}\n                    </span>\n                  </div>\n                  {/* Render the columns filter UI */}\n                  <div>{column.canFilter ? column.render(\"Filter\") : null}</div>\n                </th>\n              ))}\n            </tr>\n          ))}\n        </thead>\n        <tbody {...getTableBodyProps()}>\n          {page.map((row) => {\n            prepareRow(row);\n            return (\n              <tr {...row.getRowProps()}>\n                {row.cells.map((cell) => {\n                  return (\n                    <td {...cell.getCellProps()}>\n                      {cell.render(\"Cell\", { editable: true })}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      {/*\n        Pagination can be built however you'd like.\n        This is just a very basic UI implementation:\n      */}\n      <Pagination\n        pageSize={pageSize}\n        setPageSize={setPageSize}\n        pageIndex={pageIndex}\n        pageCount={pageCount}\n        pageOptions={pageOptions}\n        nextPage={nextPage}\n        previousPage={previousPage}\n        canNextPage={canNextPage}\n        canPreviousPage={canPreviousPage}\n        gotoPage={gotoPage}\n      />\n      <pre>\n        <code>\n          {JSON.stringify(\n            {\n              pageIndex,\n              pageSize,\n              pageCount,\n              canNextPage,\n              canPreviousPage,\n              sortBy,\n              expanded: expanded,\n              filters,\n              selectedRowIds: selectedRowIds,\n            },\n            null,\n            2\n          )}\n        </code>\n      </pre>\n    </>\n  );\n}\n\n// Define a custom filter filter function!\nfunction filterGreaterThan(rows, id, filterValue) {\n  return rows.filter((row) => {\n    const rowValue = row.values[id];\n    return rowValue >= filterValue;\n  });\n}\n\n// This is an autoRemove method on the filter function that\n// when given the new filter value and returns true, the filter\n// will be automatically removed. Normally this is just an undefined\n// check, but here, we want to remove the filter if it's not a number\nfilterGreaterThan.autoRemove = (val) => typeof val !== \"number\";\n\n// This is a custom aggregator that\n// takes in an array of leaf values and\n// returns the rounded median\nfunction roundedMedian(leafValues) {\n  let min = leafValues[0] || 0;\n  let max = leafValues[0] || 0;\n\n  leafValues.forEach((value) => {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n\n  return Math.round((min + max) / 2);\n}\n\nconst tableCols = [\n  {\n    Header: \"Id\",\n    accessor: \"id\",\n  },\n  {\n    Header: \"Name\",\n    accessor: \"name\",\n  },\n  {\n    Header: \"Prop1\",\n    accessor: \"prop1\",\n    Filter: NumberRangeColumnFilter,\n    filter: \"between\",\n  },\n  {\n    Header: \"Prop2\",\n    accessor: \"prop2\",\n  },\n  {\n    Header: \"Prop3\",\n    accessor: \"prop3\",\n    Filter: SelectColumnFilter,\n    filter: \"includes\",\n  },\n];\n\nfunction App() {\n  const columns = React.useMemo(() => tableCols, []);\n  const filterTypes = React.useMemo(customFilterTypes, []);\n  const defaultColumn = React.useMemo(defaultColumnConfig, []);\n\n  console.log({ tableData });\n  const [data, setData] = React.useState(() => tableData);\n  const [originalData] = React.useState(data);\n\n  // We need to keep the table from resetting the pageIndex when we\n  // Update data. So we can keep track of that flag with a ref.\n  const skipResetRef = React.useRef(false);\n\n  // When our cell renderer calls updateMyData, we'll use\n  // the rowIndex, columnId and new value to update the\n  // original data\n  const updateMyData = (rowIndex, columnId, value) => {\n    // We also turn on the flag to not reset the page\n    skipResetRef.current = true;\n    setData((old) =>\n      old.map((row, index) => {\n        if (index === rowIndex) {\n          return {\n            ...row,\n            [columnId]: value,\n          };\n        }\n        return row;\n      })\n    );\n  };\n\n  // After data changes, we turn the flag back off\n  // so that if data actually changes when we're not\n  // editing it, the page is reset\n  React.useEffect(() => {\n    skipResetRef.current = false;\n  }, [data]);\n\n  // Let's add a data resetter/randomizer to help\n  // illustrate that flow...\n  const resetData = () => {\n    // Don't reset the page when we do this\n    skipResetRef.current = true;\n    setData(originalData);\n  };\n\n  return (\n    <Styles>\n      <button onClick={resetData}>Reset Data</button>\n      <Table\n        columns={columns}\n        data={data}\n        updateMyData={updateMyData}\n        skipReset={skipResetRef.current}\n        filterTypes={filterTypes}\n        defaultColumn={defaultColumn}\n      />\n    </Styles>\n  );\n}\n\nexport default App;\n",["112","113"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/App.js",["114","115","116","117","118"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/data.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/NumberRangeColumnFilter.js",[],["119","120"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/SelectColumnFilter.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/customFilterTypes.js",["121"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable2.js",["122"],"import React from \"react\";\n\nimport {\n  useTable,\n  usePagination,\n  useSortBy,\n  useFilters,\n  useGroupBy,\n  useExpanded,\n  useRowSelect,\n} from \"react-table\";\n\nimport { tableData } from \"../data\";\nimport customFilterTypes from \"../filters/customFilterTypes\";\nimport NumberRangeColumnFilter from \"../filters/NumberRangeColumnFilter\";\nimport SelectColumnFilter from \"../filters/SelectColumnFilter\";\nimport DefaultColumnFilter from \"../filters/DefaultColumnFilter\";\nimport EditableCell from \"../components/EditableCell\";\nimport { useCheckboxSelection } from \"../components/CheckboxSelection\";\nimport Pagination from \"../components/Pagination\";\n\nimport Styles from \"../Styles\";\n\nconst defaultColumnConfig = () => ({\n  Filter: DefaultColumnFilter,\n  Cell: EditableCell,\n});\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction Table({\n  columns,\n  data,\n  updateMyData,\n  skipReset,\n  filterTypes,\n  defaultColumn,\n}) {\n  // Use the state and functions returned from useTable to build your UI\n  const {\n    getTableProps,\n    getTableBodyProps,\n    headerGroups,\n    prepareRow,\n    page, // Instead of using 'rows', we'll use page,\n    // which has only the rows for the active page\n\n    // The rest of these things are super handy, too ;)\n    canPreviousPage,\n    canNextPage,\n    pageOptions,\n    pageCount,\n    gotoPage,\n    nextPage,\n    previousPage,\n    setPageSize,\n    state: {\n      pageIndex,\n      pageSize,\n      sortBy,\n      groupBy,\n      expanded,\n      filters,\n      selectedRowIds,\n    },\n  } = useTable(\n    {\n      columns,\n      data,\n      defaultColumn,\n      filterTypes,\n      // updateMyData isn't part of the API, but anything we put into these options will automatically be available on the instance.\n      // That way we can call this function from our cell renderer!\n      updateMyData,\n      // We also need to pass this so the page doesn't change\n      // when we edit the data.\n      autoResetPage: !skipReset,\n      autoResetSelectedRows: !skipReset,\n      disableMultiSort: true,\n    },\n    useFilters,\n    useGroupBy,\n    useSortBy,\n    useExpanded,\n    usePagination,\n    useRowSelect,\n    // Here we will use a plugin to add our selection column\n    useCheckboxSelection\n  );\n\n  // Render the UI for your table\n  return (\n    <>\n      <table {...getTableProps()}>\n        <thead>\n          {headerGroups.map((headerGroup) => (\n            <tr {...headerGroup.getHeaderGroupProps()}>\n              {headerGroup.headers.map((column) => (\n                <th {...column.getHeaderProps()}>\n                  <div>\n                    {column.canGroupBy ? (\n                      // If the column can be grouped, let's add a toggle\n                      <span {...column.getGroupByToggleProps()}>\n                        {column.isGrouped ? \"🛑 \" : \"👊 \"}\n                      </span>\n                    ) : null}\n\n                    <span {...column.getSortByToggleProps()}>\n                      {column.render(\"Header\")}\n                      {/* Add a sort direction indicator */}\n                      {column.isSorted\n                        ? column.isSortedDesc\n                          ? \" 🔽\"\n                          : \" 🔼\"\n                        : \"\"}\n                    </span>\n                  </div>\n                  {/* Render the columns filter UI */}\n                  <div>{column.canFilter ? column.render(\"Filter\") : null}</div>\n                </th>\n              ))}\n            </tr>\n          ))}\n        </thead>\n        <tbody {...getTableBodyProps()}>\n          {page.map((row) => {\n            prepareRow(row);\n            return (\n              <tr {...row.getRowProps()}>\n                {row.cells.map((cell) => {\n                  return (\n                    <td {...cell.getCellProps()}>\n                      {cell.isGrouped ? (\n                        // If it's a grouped cell, add an expander and row count\n                        <>\n                          <span {...row.getToggleRowExpandedProps()}>\n                            {row.isExpanded ? \"👇\" : \"👉\"}\n                          </span>{\" \"}\n                          {cell.render(\"Cell\", { editable: false })} (\n                          {row.subRows.length})\n                        </>\n                      ) : cell.isAggregated ? (\n                        // If the cell is aggregated, use the Aggregated\n                        // renderer for cell\n                        cell.render(\"Aggregated\")\n                      ) : cell.isPlaceholder ? null : ( // For cells with repeated values, render null\n                        // Otherwise, just render the regular cell\n                        cell.render(\"Cell\", { editable: true })\n                      )}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      {/*\n        Pagination can be built however you'd like.\n        This is just a very basic UI implementation:\n      */}\n      <Pagination\n        pageSize={pageSize}\n        setPageSize={setPageSize}\n        pageIndex={pageIndex}\n        pageCount={pageCount}\n        pageOptions={pageOptions}\n        nextPage={nextPage}\n        previousPage={previousPage}\n        canNextPage={canNextPage}\n        canPreviousPage={canPreviousPage}\n        gotoPage={gotoPage}\n      />\n      <pre>\n        <code>\n          {JSON.stringify(\n            {\n              pageIndex,\n              pageSize,\n              pageCount,\n              canNextPage,\n              canPreviousPage,\n              sortBy,\n              groupBy,\n              expanded: expanded,\n              filters,\n              selectedRowIds: selectedRowIds,\n            },\n            null,\n            2\n          )}\n        </code>\n      </pre>\n    </>\n  );\n}\n\n// Define a custom filter filter function!\nfunction filterGreaterThan(rows, id, filterValue) {\n  return rows.filter((row) => {\n    const rowValue = row.values[id];\n    return rowValue >= filterValue;\n  });\n}\n\n// This is an autoRemove method on the filter function that\n// when given the new filter value and returns true, the filter\n// will be automatically removed. Normally this is just an undefined\n// check, but here, we want to remove the filter if it's not a number\nfilterGreaterThan.autoRemove = (val) => typeof val !== \"number\";\n\n// This is a custom aggregator that\n// takes in an array of leaf values and\n// returns the rounded median\nfunction roundedMedian(leafValues) {\n  let min = leafValues[0] || 0;\n  let max = leafValues[0] || 0;\n\n  leafValues.forEach((value) => {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n\n  return Math.round((min + max) / 2);\n}\n\nconst tableCols = [\n  {\n    Header: \"Id\",\n    accessor: \"id\",\n  },\n  {\n    Header: \"Name\",\n    accessor: \"name\",\n  },\n  {\n    Header: \"Prop1\",\n    accessor: \"prop1\",\n    Filter: NumberRangeColumnFilter,\n    filter: \"between\",\n  },\n  {\n    Header: \"Prop2\",\n    accessor: \"prop2\",\n  },\n  {\n    Header: \"Prop3\",\n    accessor: \"prop3\",\n    Filter: SelectColumnFilter,\n    filter: \"includes\",\n  },\n];\n\nfunction App() {\n  const columns = React.useMemo(() => tableCols, []);\n  const filterTypes = React.useMemo(customFilterTypes, []);\n  const defaultColumn = React.useMemo(defaultColumnConfig, []);\n\n  console.log({ tableData });\n  const [data, setData] = React.useState(() => tableData);\n  const [originalData] = React.useState(data);\n\n  // We need to keep the table from resetting the pageIndex when we\n  // Update data. So we can keep track of that flag with a ref.\n  const skipResetRef = React.useRef(false);\n\n  // When our cell renderer calls updateMyData, we'll use\n  // the rowIndex, columnId and new value to update the\n  // original data\n  const updateMyData = (rowIndex, columnId, value) => {\n    // We also turn on the flag to not reset the page\n    skipResetRef.current = true;\n    setData((old) =>\n      old.map((row, index) => {\n        if (index === rowIndex) {\n          return {\n            ...row,\n            [columnId]: value,\n          };\n        }\n        return row;\n      })\n    );\n  };\n\n  // After data changes, we turn the flag back off\n  // so that if data actually changes when we're not\n  // editing it, the page is reset\n  React.useEffect(() => {\n    skipResetRef.current = false;\n  }, [data]);\n\n  // Let's add a data resetter/randomizer to help\n  // illustrate that flow...\n  const resetData = () => {\n    // Don't reset the page when we do this\n    skipResetRef.current = true;\n    setData(originalData);\n  };\n\n  return (\n    <Styles>\n      <button onClick={resetData}>Reset Data</button>\n      <Table\n        columns={columns}\n        data={data}\n        updateMyData={updateMyData}\n        skipReset={skipResetRef.current}\n        filterTypes={filterTypes}\n        defaultColumn={defaultColumn}\n      />\n    </Styles>\n  );\n}\n\nexport default App;\n","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/CheckboxSelection.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable3.js",["123"],"import React from \"react\";\n\nimport {\n  useTable,\n  usePagination,\n  useSortBy,\n  useFilters,\n  useGroupBy,\n  useExpanded,\n  useRowSelect,\n} from \"react-table\";\n\nimport { tableData } from \"../data\";\nimport customFilterTypes from \"../filters/customFilterTypes\";\nimport NumberRangeColumnFilter from \"../filters/NumberRangeColumnFilter\";\nimport SelectColumnFilter from \"../filters/SelectColumnFilter\";\nimport DefaultColumnFilter from \"../filters/DefaultColumnFilter\";\nimport EditableCell from \"../components/EditableCell\";\nimport { useCheckboxSelection } from \"../components/CheckboxSelection\";\nimport Pagination from \"../components/Pagination\";\n\nimport Styles from \"../Styles\";\n\nconst defaultColumnConfig = () => ({\n  Filter: DefaultColumnFilter,\n  Cell: EditableCell,\n});\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction Table({\n  columns,\n  data,\n  updateMyData,\n  skipReset,\n  filterTypes,\n  defaultColumn,\n}) {\n  // Use the state and functions returned from useTable to build your UI\n  const {\n    getTableProps,\n    getTableBodyProps,\n    headerGroups,\n    prepareRow,\n    page, // Instead of using 'rows', we'll use page,\n    // which has only the rows for the active page\n\n    // The rest of these things are super handy, too ;)\n    canPreviousPage,\n    canNextPage,\n    pageOptions,\n    pageCount,\n    gotoPage,\n    nextPage,\n    previousPage,\n    setPageSize,\n    state: {\n      pageIndex,\n      pageSize,\n      sortBy,\n      groupBy,\n      expanded,\n      filters,\n      selectedRowIds,\n    },\n  } = useTable(\n    {\n      columns,\n      data,\n      defaultColumn,\n      filterTypes,\n      // updateMyData isn't part of the API, but anything we put into these options will automatically be available on the instance.\n      // That way we can call this function from our cell renderer!\n      updateMyData,\n      // We also need to pass this so the page doesn't change\n      // when we edit the data.\n      autoResetPage: !skipReset,\n      autoResetSelectedRows: !skipReset,\n      disableMultiSort: true,\n    },\n    useFilters,\n    useGroupBy,\n    useSortBy,\n    useExpanded,\n    usePagination,\n    useRowSelect,\n    // Here we will use a plugin to add our selection column\n    useCheckboxSelection\n  );\n\n  // Render the UI for your table\n  return (\n    <>\n      <table {...getTableProps()}>\n        <thead>\n          {headerGroups.map((headerGroup) => (\n            <tr {...headerGroup.getHeaderGroupProps()}>\n              {headerGroup.headers.map((column) => (\n                <th {...column.getHeaderProps()}>\n                  <div>\n                    {column.canGroupBy ? (\n                      // If the column can be grouped, let's add a toggle\n                      <span {...column.getGroupByToggleProps()}>\n                        {column.isGrouped ? \"🛑 \" : \"👊 \"}\n                      </span>\n                    ) : null}\n\n                    <span {...column.getSortByToggleProps()}>\n                      {column.render(\"Header\")}\n                      {/* Add a sort direction indicator */}\n                      {column.isSorted\n                        ? column.isSortedDesc\n                          ? \" 🔽\"\n                          : \" 🔼\"\n                        : \"\"}\n                    </span>\n                  </div>\n                  {/* Render the columns filter UI */}\n                  <div>{column.canFilter ? column.render(\"Filter\") : null}</div>\n                </th>\n              ))}\n            </tr>\n          ))}\n        </thead>\n        <tbody {...getTableBodyProps()}>\n          {page.map((row) => {\n            prepareRow(row);\n            return (\n              <tr {...row.getRowProps()}>\n                {row.cells.map((cell) => {\n                  return (\n                    <td {...cell.getCellProps()}>\n                      {cell.isGrouped ? (\n                        // If it's a grouped cell, add an expander and row count\n                        <>\n                          <span {...row.getToggleRowExpandedProps()}>\n                            {row.isExpanded ? \"👇\" : \"👉\"}\n                          </span>{\" \"}\n                          {cell.render(\"Cell\", { editable: false })} (\n                          {row.subRows.length})\n                        </>\n                      ) : cell.isAggregated ? (\n                        // If the cell is aggregated, use the Aggregated\n                        // renderer for cell\n                        cell.render(\"Aggregated\")\n                      ) : cell.isPlaceholder ? null : ( // For cells with repeated values, render null\n                        // Otherwise, just render the regular cell\n                        cell.render(\"Cell\", { editable: true })\n                      )}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      {/*\n        Pagination can be built however you'd like.\n        This is just a very basic UI implementation:\n      */}\n      <Pagination\n        pageSize={pageSize}\n        setPageSize={setPageSize}\n        pageIndex={pageIndex}\n        pageCount={pageCount}\n        pageOptions={pageOptions}\n        nextPage={nextPage}\n        previousPage={previousPage}\n        canNextPage={canNextPage}\n        canPreviousPage={canPreviousPage}\n        gotoPage={gotoPage}\n      />\n      <pre>\n        <code>\n          {JSON.stringify(\n            {\n              pageIndex,\n              pageSize,\n              pageCount,\n              canNextPage,\n              canPreviousPage,\n              sortBy,\n              groupBy,\n              expanded: expanded,\n              filters,\n              selectedRowIds: selectedRowIds,\n            },\n            null,\n            2\n          )}\n        </code>\n      </pre>\n    </>\n  );\n}\n\n// Define a custom filter filter function!\nfunction filterGreaterThan(rows, id, filterValue) {\n  return rows.filter((row) => {\n    const rowValue = row.values[id];\n    return rowValue >= filterValue;\n  });\n}\n\n// This is an autoRemove method on the filter function that\n// when given the new filter value and returns true, the filter\n// will be automatically removed. Normally this is just an undefined\n// check, but here, we want to remove the filter if it's not a number\nfilterGreaterThan.autoRemove = (val) => typeof val !== \"number\";\n\n// This is a custom aggregator that\n// takes in an array of leaf values and\n// returns the rounded median\nfunction roundedMedian(leafValues) {\n  let min = leafValues[0] || 0;\n  let max = leafValues[0] || 0;\n\n  leafValues.forEach((value) => {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n\n  return Math.round((min + max) / 2);\n}\n\nconst tableCols = [\n  {\n    Header: \"Id\",\n    accessor: \"id\",\n  },\n  {\n    Header: \"Name\",\n    accessor: \"name\",\n  },\n\n  {\n    Header: \"Prop1\",\n    accessor: \"prop1\",\n    Filter: NumberRangeColumnFilter,\n    filter: \"between\",\n  },\n\n  {\n    Header: \"Prop2 & Prop3\",\n    columns: [\n      {\n        Header: \"Prop2\",\n        accessor: \"prop2\",\n      },\n      {\n        Header: \"Prop3\",\n        accessor: \"prop3\",\n        Filter: SelectColumnFilter,\n        filter: \"includes\",\n      },\n    ],\n  },\n];\n\nfunction App() {\n  const columns = React.useMemo(() => tableCols, []);\n  const filterTypes = React.useMemo(customFilterTypes, []);\n  const defaultColumn = React.useMemo(defaultColumnConfig, []);\n\n  console.log({ tableData });\n  const [data, setData] = React.useState(() => tableData);\n  const [originalData] = React.useState(data);\n\n  // We need to keep the table from resetting the pageIndex when we\n  // Update data. So we can keep track of that flag with a ref.\n  const skipResetRef = React.useRef(false);\n\n  // When our cell renderer calls updateMyData, we'll use\n  // the rowIndex, columnId and new value to update the\n  // original data\n  const updateMyData = (rowIndex, columnId, value) => {\n    // We also turn on the flag to not reset the page\n    skipResetRef.current = true;\n    setData((old) =>\n      old.map((row, index) => {\n        if (index === rowIndex) {\n          return {\n            ...row,\n            [columnId]: value,\n          };\n        }\n        return row;\n      })\n    );\n  };\n\n  // After data changes, we turn the flag back off\n  // so that if data actually changes when we're not\n  // editing it, the page is reset\n  React.useEffect(() => {\n    skipResetRef.current = false;\n  }, [data]);\n\n  // Let's add a data resetter/randomizer to help\n  // illustrate that flow...\n  const resetData = () => {\n    // Don't reset the page when we do this\n    skipResetRef.current = true;\n    setData(originalData);\n  };\n\n  return (\n    <Styles>\n      <button onClick={resetData}>Reset Data</button>\n      <Table\n        columns={columns}\n        data={data}\n        updateMyData={updateMyData}\n        skipReset={skipResetRef.current}\n        filterTypes={filterTypes}\n        defaultColumn={defaultColumn}\n      />\n    </Styles>\n  );\n}\n\nexport default App;\n","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable4.js",["124"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/Styles.js",["125"],"import React from \"react\";\nimport styled from \"styled-components\";\nconst Styles = styled.div`\n  padding: 1rem;\n\n  table {\n    border-spacing: 0;\n    border: 1px solid black;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding: 0.5rem;\n      border-bottom: 1px solid black;\n      border-right: 1px solid black;\n\n      :last-child {\n        border-right: 0;\n      }\n    }\n\n    td {\n      input {\n        font-size: 1rem;\n        padding: 0;\n        margin: 0;\n        border: 0;\n      }\n    }\n  }\n\n  .search {\n    width: 300px;\n    padding: 10px;\n    margin-top: 10px;\n    margin-bottom: 10px;\n  }\n  .pagination {\n    padding: 0.5rem;\n  }\n`;\n\nexport default Styles;\n","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/GlobalSearchFilter.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/Pagination.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TableShowHideColumns.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/index.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/data.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/options/columns.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/index.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/options/filterTypes.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TablePagination.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TableDebugVals.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable5/Table/components/TableAppliedFilters.js",[],{"ruleId":"126","replacedBy":"127"},{"ruleId":"128","replacedBy":"129"},{"ruleId":"126","replacedBy":"130"},{"ruleId":"128","replacedBy":"131"},{"ruleId":"132","severity":1,"message":"133","line":12,"column":21,"nodeType":"134","messageId":"135","endLine":12,"endColumn":31},{"ruleId":"132","severity":1,"message":"136","line":180,"column":10,"nodeType":"134","messageId":"135","endLine":180,"endColumn":23},{"ruleId":"126","replacedBy":"137"},{"ruleId":"128","replacedBy":"138"},{"ruleId":"132","severity":1,"message":"139","line":2,"column":8,"nodeType":"134","messageId":"135","endLine":2,"endColumn":12},{"ruleId":"132","severity":1,"message":"140","line":5,"column":8,"nodeType":"134","messageId":"135","endLine":5,"endColumn":17},{"ruleId":"132","severity":1,"message":"141","line":6,"column":8,"nodeType":"134","messageId":"135","endLine":6,"endColumn":17},{"ruleId":"132","severity":1,"message":"142","line":7,"column":8,"nodeType":"134","messageId":"135","endLine":7,"endColumn":17},{"ruleId":"132","severity":1,"message":"143","line":8,"column":8,"nodeType":"134","messageId":"135","endLine":8,"endColumn":17},{"ruleId":"126","replacedBy":"144"},{"ruleId":"128","replacedBy":"145"},{"ruleId":"132","severity":1,"message":"146","line":1,"column":8,"nodeType":"134","messageId":"135","endLine":1,"endColumn":13},{"ruleId":"132","severity":1,"message":"136","line":214,"column":10,"nodeType":"134","messageId":"135","endLine":214,"endColumn":23},{"ruleId":"132","severity":1,"message":"136","line":214,"column":10,"nodeType":"134","messageId":"135","endLine":214,"endColumn":23},{"ruleId":"132","severity":1,"message":"136","line":225,"column":10,"nodeType":"134","messageId":"135","endLine":225,"endColumn":23},{"ruleId":"132","severity":1,"message":"146","line":1,"column":8,"nodeType":"134","messageId":"135","endLine":1,"endColumn":13},"no-native-reassign",["147"],"no-negated-in-lhs",["148"],["147"],["148"],"no-unused-vars","'tableData1' is defined but never used.","Identifier","unusedVar","'roundedMedian' is defined but never used.",["147"],["148"],"'logo' is defined but never used.","'JagTable1' is defined but never used.","'JagTable2' is defined but never used.","'JagTable3' is defined but never used.","'JagTable4' is defined but never used.",["147"],["148"],"'React' is defined but never used.","no-global-assign","no-unsafe-negation"]