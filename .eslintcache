[{"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/index.js":"1","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/reportWebVitals.js":"2","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable1.js":"3","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/App.js":"4","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/data.js":"5","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/NumberRangeColumnFilter.js":"6","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/SelectColumnFilter.js":"7","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/customFilterTypes.js":"8","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable2.js":"9","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/CheckboxSelection.js":"10","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable3.js":"11","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable4.js":"12","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/Styles.js":"13","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/GlobalSearchFilter.js":"14","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/ResearchTable.js":"15","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/data.js":"16","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/StockApp.js":"17","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/Pagination.js":"18","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/utils.js":"19"},{"size":500,"mtime":1608548282182,"results":"20","hashOfConfig":"21"},{"size":362,"mtime":1608547427832,"results":"22","hashOfConfig":"21"},{"size":7593,"mtime":1608558009775,"results":"23","hashOfConfig":"21"},{"size":583,"mtime":1609309730379,"results":"24","hashOfConfig":"21"},{"size":193,"mtime":1608553503167,"results":"25","hashOfConfig":"21"},{"size":1550,"mtime":1608548783452,"results":"26","hashOfConfig":"21"},{"size":849,"mtime":1608549006395,"results":"27","hashOfConfig":"21"},{"size":862,"mtime":1608549661576,"results":"28","hashOfConfig":"21"},{"size":8876,"mtime":1608558024869,"results":"29","hashOfConfig":"21"},{"size":1317,"mtime":1608551710573,"results":"30","hashOfConfig":"21"},{"size":8978,"mtime":1608558036948,"results":"31","hashOfConfig":"21"},{"size":9326,"mtime":1608569132263,"results":"32","hashOfConfig":"21"},{"size":756,"mtime":1608568954629,"results":"33","hashOfConfig":"21"},{"size":706,"mtime":1608569135585,"results":"34","hashOfConfig":"21"},{"size":10880,"mtime":1609312361736,"results":"35","hashOfConfig":"21"},{"size":25002,"mtime":1609311662398,"results":"36","hashOfConfig":"21"},{"size":2026,"mtime":1609311612396,"results":"37","hashOfConfig":"21"},{"size":1479,"mtime":1608553161272,"results":"38","hashOfConfig":"21"},{"size":1358,"mtime":1609312229477,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"7w60ns",{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"45"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"49"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73","usedDeprecatedRules":"56"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"78","messages":"79","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"80","messages":"81","errorCount":1,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86"},"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/index.js",[],["87","88"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/reportWebVitals.js",[],["89","90"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable1.js",["91","92"],"import React from \"react\";\n\nimport {\n  useTable,\n  usePagination,\n  useSortBy,\n  useFilters,\n  useExpanded,\n  useRowSelect,\n} from \"react-table\";\n\nimport { tableData, tableData1 } from \"../data\";\nimport customFilterTypes from \"../filters/customFilterTypes\";\nimport NumberRangeColumnFilter from \"../filters/NumberRangeColumnFilter\";\nimport SelectColumnFilter from \"../filters/SelectColumnFilter\";\nimport DefaultColumnFilter from \"../filters/DefaultColumnFilter\";\nimport EditableCell from \"../components/EditableCell\";\nimport { useCheckboxSelection } from \"../components/CheckboxSelection\";\nimport Pagination from \"../components/Pagination\";\n\nimport Styles from \"../Styles\";\n\nconst defaultColumnConfig = () => ({\n  Filter: DefaultColumnFilter,\n  Cell: EditableCell,\n});\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction Table({\n  columns,\n  data,\n  updateMyData,\n  skipReset,\n  filterTypes,\n  defaultColumn,\n}) {\n  // Use the state and functions returned from useTable to build your UI\n  const {\n    getTableProps,\n    getTableBodyProps,\n    headerGroups,\n    prepareRow,\n    page, // Instead of using 'rows', we'll use page,\n    // which has only the rows for the active page\n\n    // The rest of these things are super handy, too ;)\n    canPreviousPage,\n    canNextPage,\n    pageOptions,\n    pageCount,\n    gotoPage,\n    nextPage,\n    previousPage,\n    setPageSize,\n    state: { pageIndex, pageSize, sortBy, expanded, filters, selectedRowIds },\n  } = useTable(\n    {\n      columns,\n      data,\n      defaultColumn,\n      filterTypes,\n      // updateMyData isn't part of the API, but anything we put into these options will automatically be available on the instance.\n      // That way we can call this function from our cell renderer!\n      updateMyData,\n      // We also need to pass this so the page doesn't change\n      // when we edit the data.\n      autoResetPage: !skipReset,\n      autoResetSelectedRows: !skipReset,\n      disableMultiSort: true,\n    },\n    useFilters,\n    useSortBy,\n    useExpanded,\n    usePagination,\n    useRowSelect,\n    // Here we will use a plugin to add our selection column\n    useCheckboxSelection\n  );\n\n  // Render the UI for your table\n  return (\n    <>\n      <table {...getTableProps()}>\n        <thead>\n          {headerGroups.map((headerGroup) => (\n            <tr {...headerGroup.getHeaderGroupProps()}>\n              {headerGroup.headers.map((column) => (\n                <th {...column.getHeaderProps()}>\n                  <div>\n                    <span {...column.getSortByToggleProps()}>\n                      {column.render(\"Header\")}\n                      {/* Add a sort direction indicator */}\n                      {column.isSorted\n                        ? column.isSortedDesc\n                          ? \" ðŸ”½\"\n                          : \" ðŸ”¼\"\n                        : \"\"}\n                    </span>\n                  </div>\n                  {/* Render the columns filter UI */}\n                  <div>{column.canFilter ? column.render(\"Filter\") : null}</div>\n                </th>\n              ))}\n            </tr>\n          ))}\n        </thead>\n        <tbody {...getTableBodyProps()}>\n          {page.map((row) => {\n            prepareRow(row);\n            return (\n              <tr {...row.getRowProps()}>\n                {row.cells.map((cell) => {\n                  return (\n                    <td {...cell.getCellProps()}>\n                      {cell.render(\"Cell\", { editable: true })}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      {/*\n        Pagination can be built however you'd like.\n        This is just a very basic UI implementation:\n      */}\n      <Pagination\n        pageSize={pageSize}\n        setPageSize={setPageSize}\n        pageIndex={pageIndex}\n        pageCount={pageCount}\n        pageOptions={pageOptions}\n        nextPage={nextPage}\n        previousPage={previousPage}\n        canNextPage={canNextPage}\n        canPreviousPage={canPreviousPage}\n        gotoPage={gotoPage}\n      />\n      <pre>\n        <code>\n          {JSON.stringify(\n            {\n              pageIndex,\n              pageSize,\n              pageCount,\n              canNextPage,\n              canPreviousPage,\n              sortBy,\n              expanded: expanded,\n              filters,\n              selectedRowIds: selectedRowIds,\n            },\n            null,\n            2\n          )}\n        </code>\n      </pre>\n    </>\n  );\n}\n\n// Define a custom filter filter function!\nfunction filterGreaterThan(rows, id, filterValue) {\n  return rows.filter((row) => {\n    const rowValue = row.values[id];\n    return rowValue >= filterValue;\n  });\n}\n\n// This is an autoRemove method on the filter function that\n// when given the new filter value and returns true, the filter\n// will be automatically removed. Normally this is just an undefined\n// check, but here, we want to remove the filter if it's not a number\nfilterGreaterThan.autoRemove = (val) => typeof val !== \"number\";\n\n// This is a custom aggregator that\n// takes in an array of leaf values and\n// returns the rounded median\nfunction roundedMedian(leafValues) {\n  let min = leafValues[0] || 0;\n  let max = leafValues[0] || 0;\n\n  leafValues.forEach((value) => {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n\n  return Math.round((min + max) / 2);\n}\n\nconst tableCols = [\n  {\n    Header: \"Id\",\n    accessor: \"id\",\n  },\n  {\n    Header: \"Name\",\n    accessor: \"name\",\n  },\n  {\n    Header: \"Prop1\",\n    accessor: \"prop1\",\n    Filter: NumberRangeColumnFilter,\n    filter: \"between\",\n  },\n  {\n    Header: \"Prop2\",\n    accessor: \"prop2\",\n  },\n  {\n    Header: \"Prop3\",\n    accessor: \"prop3\",\n    Filter: SelectColumnFilter,\n    filter: \"includes\",\n  },\n];\n\nfunction App() {\n  const columns = React.useMemo(() => tableCols, []);\n  const filterTypes = React.useMemo(customFilterTypes, []);\n  const defaultColumn = React.useMemo(defaultColumnConfig, []);\n\n  console.log({ tableData });\n  const [data, setData] = React.useState(() => tableData);\n  const [originalData] = React.useState(data);\n\n  // We need to keep the table from resetting the pageIndex when we\n  // Update data. So we can keep track of that flag with a ref.\n  const skipResetRef = React.useRef(false);\n\n  // When our cell renderer calls updateMyData, we'll use\n  // the rowIndex, columnId and new value to update the\n  // original data\n  const updateMyData = (rowIndex, columnId, value) => {\n    // We also turn on the flag to not reset the page\n    skipResetRef.current = true;\n    setData((old) =>\n      old.map((row, index) => {\n        if (index === rowIndex) {\n          return {\n            ...row,\n            [columnId]: value,\n          };\n        }\n        return row;\n      })\n    );\n  };\n\n  // After data changes, we turn the flag back off\n  // so that if data actually changes when we're not\n  // editing it, the page is reset\n  React.useEffect(() => {\n    skipResetRef.current = false;\n  }, [data]);\n\n  // Let's add a data resetter/randomizer to help\n  // illustrate that flow...\n  const resetData = () => {\n    // Don't reset the page when we do this\n    skipResetRef.current = true;\n    setData(originalData);\n  };\n\n  return (\n    <Styles>\n      <button onClick={resetData}>Reset Data</button>\n      <Table\n        columns={columns}\n        data={data}\n        updateMyData={updateMyData}\n        skipReset={skipResetRef.current}\n        filterTypes={filterTypes}\n        defaultColumn={defaultColumn}\n      />\n    </Styles>\n  );\n}\n\nexport default App;\n",["93","94"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/App.js",["95","96","97","98","99"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/data.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/NumberRangeColumnFilter.js",[],["100","101"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/SelectColumnFilter.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/filters/customFilterTypes.js",["102"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable2.js",["103"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/CheckboxSelection.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable3.js",["104"],"import React from \"react\";\n\nimport {\n  useTable,\n  usePagination,\n  useSortBy,\n  useFilters,\n  useGroupBy,\n  useExpanded,\n  useRowSelect,\n} from \"react-table\";\n\nimport { tableData } from \"../data\";\nimport customFilterTypes from \"../filters/customFilterTypes\";\nimport NumberRangeColumnFilter from \"../filters/NumberRangeColumnFilter\";\nimport SelectColumnFilter from \"../filters/SelectColumnFilter\";\nimport DefaultColumnFilter from \"../filters/DefaultColumnFilter\";\nimport EditableCell from \"../components/EditableCell\";\nimport { useCheckboxSelection } from \"../components/CheckboxSelection\";\nimport Pagination from \"../components/Pagination\";\n\nimport Styles from \"../Styles\";\n\nconst defaultColumnConfig = () => ({\n  Filter: DefaultColumnFilter,\n  Cell: EditableCell,\n});\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction Table({\n  columns,\n  data,\n  updateMyData,\n  skipReset,\n  filterTypes,\n  defaultColumn,\n}) {\n  // Use the state and functions returned from useTable to build your UI\n  const {\n    getTableProps,\n    getTableBodyProps,\n    headerGroups,\n    prepareRow,\n    page, // Instead of using 'rows', we'll use page,\n    // which has only the rows for the active page\n\n    // The rest of these things are super handy, too ;)\n    canPreviousPage,\n    canNextPage,\n    pageOptions,\n    pageCount,\n    gotoPage,\n    nextPage,\n    previousPage,\n    setPageSize,\n    state: {\n      pageIndex,\n      pageSize,\n      sortBy,\n      groupBy,\n      expanded,\n      filters,\n      selectedRowIds,\n    },\n  } = useTable(\n    {\n      columns,\n      data,\n      defaultColumn,\n      filterTypes,\n      // updateMyData isn't part of the API, but anything we put into these options will automatically be available on the instance.\n      // That way we can call this function from our cell renderer!\n      updateMyData,\n      // We also need to pass this so the page doesn't change\n      // when we edit the data.\n      autoResetPage: !skipReset,\n      autoResetSelectedRows: !skipReset,\n      disableMultiSort: true,\n    },\n    useFilters,\n    useGroupBy,\n    useSortBy,\n    useExpanded,\n    usePagination,\n    useRowSelect,\n    // Here we will use a plugin to add our selection column\n    useCheckboxSelection\n  );\n\n  // Render the UI for your table\n  return (\n    <>\n      <table {...getTableProps()}>\n        <thead>\n          {headerGroups.map((headerGroup) => (\n            <tr {...headerGroup.getHeaderGroupProps()}>\n              {headerGroup.headers.map((column) => (\n                <th {...column.getHeaderProps()}>\n                  <div>\n                    {column.canGroupBy ? (\n                      // If the column can be grouped, let's add a toggle\n                      <span {...column.getGroupByToggleProps()}>\n                        {column.isGrouped ? \"ðŸ›‘ \" : \"ðŸ‘Š \"}\n                      </span>\n                    ) : null}\n\n                    <span {...column.getSortByToggleProps()}>\n                      {column.render(\"Header\")}\n                      {/* Add a sort direction indicator */}\n                      {column.isSorted\n                        ? column.isSortedDesc\n                          ? \" ðŸ”½\"\n                          : \" ðŸ”¼\"\n                        : \"\"}\n                    </span>\n                  </div>\n                  {/* Render the columns filter UI */}\n                  <div>{column.canFilter ? column.render(\"Filter\") : null}</div>\n                </th>\n              ))}\n            </tr>\n          ))}\n        </thead>\n        <tbody {...getTableBodyProps()}>\n          {page.map((row) => {\n            prepareRow(row);\n            return (\n              <tr {...row.getRowProps()}>\n                {row.cells.map((cell) => {\n                  return (\n                    <td {...cell.getCellProps()}>\n                      {cell.isGrouped ? (\n                        // If it's a grouped cell, add an expander and row count\n                        <>\n                          <span {...row.getToggleRowExpandedProps()}>\n                            {row.isExpanded ? \"ðŸ‘‡\" : \"ðŸ‘‰\"}\n                          </span>{\" \"}\n                          {cell.render(\"Cell\", { editable: false })} (\n                          {row.subRows.length})\n                        </>\n                      ) : cell.isAggregated ? (\n                        // If the cell is aggregated, use the Aggregated\n                        // renderer for cell\n                        cell.render(\"Aggregated\")\n                      ) : cell.isPlaceholder ? null : ( // For cells with repeated values, render null\n                        // Otherwise, just render the regular cell\n                        cell.render(\"Cell\", { editable: true })\n                      )}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      {/*\n        Pagination can be built however you'd like.\n        This is just a very basic UI implementation:\n      */}\n      <Pagination\n        pageSize={pageSize}\n        setPageSize={setPageSize}\n        pageIndex={pageIndex}\n        pageCount={pageCount}\n        pageOptions={pageOptions}\n        nextPage={nextPage}\n        previousPage={previousPage}\n        canNextPage={canNextPage}\n        canPreviousPage={canPreviousPage}\n        gotoPage={gotoPage}\n      />\n      <pre>\n        <code>\n          {JSON.stringify(\n            {\n              pageIndex,\n              pageSize,\n              pageCount,\n              canNextPage,\n              canPreviousPage,\n              sortBy,\n              groupBy,\n              expanded: expanded,\n              filters,\n              selectedRowIds: selectedRowIds,\n            },\n            null,\n            2\n          )}\n        </code>\n      </pre>\n    </>\n  );\n}\n\n// Define a custom filter filter function!\nfunction filterGreaterThan(rows, id, filterValue) {\n  return rows.filter((row) => {\n    const rowValue = row.values[id];\n    return rowValue >= filterValue;\n  });\n}\n\n// This is an autoRemove method on the filter function that\n// when given the new filter value and returns true, the filter\n// will be automatically removed. Normally this is just an undefined\n// check, but here, we want to remove the filter if it's not a number\nfilterGreaterThan.autoRemove = (val) => typeof val !== \"number\";\n\n// This is a custom aggregator that\n// takes in an array of leaf values and\n// returns the rounded median\nfunction roundedMedian(leafValues) {\n  let min = leafValues[0] || 0;\n  let max = leafValues[0] || 0;\n\n  leafValues.forEach((value) => {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n\n  return Math.round((min + max) / 2);\n}\n\nconst tableCols = [\n  {\n    Header: \"Id\",\n    accessor: \"id\",\n  },\n  {\n    Header: \"Name\",\n    accessor: \"name\",\n  },\n\n  {\n    Header: \"Prop1\",\n    accessor: \"prop1\",\n    Filter: NumberRangeColumnFilter,\n    filter: \"between\",\n  },\n\n  {\n    Header: \"Prop2 & Prop3\",\n    columns: [\n      {\n        Header: \"Prop2\",\n        accessor: \"prop2\",\n      },\n      {\n        Header: \"Prop3\",\n        accessor: \"prop3\",\n        Filter: SelectColumnFilter,\n        filter: \"includes\",\n      },\n    ],\n  },\n];\n\nfunction App() {\n  const columns = React.useMemo(() => tableCols, []);\n  const filterTypes = React.useMemo(customFilterTypes, []);\n  const defaultColumn = React.useMemo(defaultColumnConfig, []);\n\n  console.log({ tableData });\n  const [data, setData] = React.useState(() => tableData);\n  const [originalData] = React.useState(data);\n\n  // We need to keep the table from resetting the pageIndex when we\n  // Update data. So we can keep track of that flag with a ref.\n  const skipResetRef = React.useRef(false);\n\n  // When our cell renderer calls updateMyData, we'll use\n  // the rowIndex, columnId and new value to update the\n  // original data\n  const updateMyData = (rowIndex, columnId, value) => {\n    // We also turn on the flag to not reset the page\n    skipResetRef.current = true;\n    setData((old) =>\n      old.map((row, index) => {\n        if (index === rowIndex) {\n          return {\n            ...row,\n            [columnId]: value,\n          };\n        }\n        return row;\n      })\n    );\n  };\n\n  // After data changes, we turn the flag back off\n  // so that if data actually changes when we're not\n  // editing it, the page is reset\n  React.useEffect(() => {\n    skipResetRef.current = false;\n  }, [data]);\n\n  // Let's add a data resetter/randomizer to help\n  // illustrate that flow...\n  const resetData = () => {\n    // Don't reset the page when we do this\n    skipResetRef.current = true;\n    setData(originalData);\n  };\n\n  return (\n    <Styles>\n      <button onClick={resetData}>Reset Data</button>\n      <Table\n        columns={columns}\n        data={data}\n        updateMyData={updateMyData}\n        skipReset={skipResetRef.current}\n        filterTypes={filterTypes}\n        defaultColumn={defaultColumn}\n      />\n    </Styles>\n  );\n}\n\nexport default App;\n","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/examples/JagTable4.js",["105"],"import React from \"react\";\n\nimport {\n  useTable,\n  usePagination,\n  useSortBy,\n  useFilters,\n  useGlobalFilter,\n  useGroupBy,\n  useExpanded,\n  useRowSelect,\n} from \"react-table\";\n\nimport { tableData } from \"../data\";\nimport customFilterTypes from \"../filters/customFilterTypes\";\nimport NumberRangeColumnFilter from \"../filters/NumberRangeColumnFilter\";\nimport SelectColumnFilter from \"../filters/SelectColumnFilter\";\nimport DefaultColumnFilter from \"../filters/DefaultColumnFilter\";\nimport EditableCell from \"../components/EditableCell\";\nimport { useCheckboxSelection } from \"../components/CheckboxSelection\";\nimport Pagination from \"../components/Pagination\";\nimport GlobalSearchFilter from \"../components/GlobalSearchFilter\";\n\nimport Styles from \"../Styles\";\n\nconst defaultColumnConfig = () => ({\n  Filter: DefaultColumnFilter,\n  Cell: EditableCell,\n});\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction Table({\n  columns,\n  data,\n  updateMyData,\n  skipReset,\n  filterTypes,\n  defaultColumn,\n}) {\n  // Use the state and functions returned from useTable to build your UI\n  const {\n    getTableProps,\n    getTableBodyProps,\n    headerGroups,\n    prepareRow,\n    page, // Instead of using 'rows', we'll use page,\n    // which has only the rows for the active page\n\n    // The rest of these things are super handy, too ;)\n    canPreviousPage,\n    canNextPage,\n    pageOptions,\n    pageCount,\n    gotoPage,\n    nextPage,\n    previousPage,\n    setPageSize,\n    preGlobalFilteredRows,\n    setGlobalFilter,\n    state: {\n      pageIndex,\n      pageSize,\n      sortBy,\n      groupBy,\n      expanded,\n      filters,\n      selectedRowIds,\n      globalFilter,\n    },\n  } = useTable(\n    {\n      columns,\n      data,\n      defaultColumn,\n      filterTypes,\n      // updateMyData isn't part of the API, but anything we put into these options will automatically be available on the instance.\n      // That way we can call this function from our cell renderer!\n      updateMyData,\n      // We also need to pass this so the page doesn't change\n      // when we edit the data.\n      autoResetPage: !skipReset,\n      autoResetSelectedRows: !skipReset,\n      disableMultiSort: true,\n    },\n    useFilters,\n    useGlobalFilter,\n    useGroupBy,\n    useSortBy,\n    useExpanded,\n    usePagination,\n    useRowSelect,\n    // Here we will use a plugin to add our selection column\n    useCheckboxSelection\n  );\n\n  // Render the UI for your table\n  return (\n    <div>\n      <GlobalSearchFilter\n        preGlobalFilteredRows={preGlobalFilteredRows}\n        globalFilter={globalFilter}\n        setGlobalFilter={setGlobalFilter}\n      />\n      <table {...getTableProps()}>\n        <thead>\n          {headerGroups.map((headerGroup) => (\n            <tr {...headerGroup.getHeaderGroupProps()}>\n              {headerGroup.headers.map((column) => (\n                <th {...column.getHeaderProps()}>\n                  <div>\n                    {column.canGroupBy ? (\n                      // If the column can be grouped, let's add a toggle\n                      <span {...column.getGroupByToggleProps()}>\n                        {column.isGrouped ? \"ðŸ›‘ \" : \"ðŸ‘Š \"}\n                      </span>\n                    ) : null}\n\n                    <span {...column.getSortByToggleProps()}>\n                      {column.render(\"Header\")}\n                      {/* Add a sort direction indicator */}\n                      {column.isSorted\n                        ? column.isSortedDesc\n                          ? \" ðŸ”½\"\n                          : \" ðŸ”¼\"\n                        : \"\"}\n                    </span>\n                  </div>\n                  {/* Render the columns filter UI */}\n                  <div>{column.canFilter ? column.render(\"Filter\") : null}</div>\n                </th>\n              ))}\n            </tr>\n          ))}\n        </thead>\n        <tbody {...getTableBodyProps()}>\n          {page.map((row) => {\n            prepareRow(row);\n            return (\n              <tr {...row.getRowProps()}>\n                {row.cells.map((cell) => {\n                  return (\n                    <td {...cell.getCellProps()}>\n                      {cell.isGrouped ? (\n                        // If it's a grouped cell, add an expander and row count\n                        <>\n                          <span {...row.getToggleRowExpandedProps()}>\n                            {row.isExpanded ? \"ðŸ‘‡\" : \"ðŸ‘‰\"}\n                          </span>{\" \"}\n                          {cell.render(\"Cell\", { editable: false })} (\n                          {row.subRows.length})\n                        </>\n                      ) : cell.isAggregated ? (\n                        // If the cell is aggregated, use the Aggregated\n                        // renderer for cell\n                        cell.render(\"Aggregated\")\n                      ) : cell.isPlaceholder ? null : ( // For cells with repeated values, render null\n                        // Otherwise, just render the regular cell\n                        cell.render(\"Cell\", { editable: true })\n                      )}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      {/*\n        Pagination can be built however you'd like.\n        This is just a very basic UI implementation:\n      */}\n      <Pagination\n        pageSize={pageSize}\n        setPageSize={setPageSize}\n        pageIndex={pageIndex}\n        pageCount={pageCount}\n        pageOptions={pageOptions}\n        nextPage={nextPage}\n        previousPage={previousPage}\n        canNextPage={canNextPage}\n        canPreviousPage={canPreviousPage}\n        gotoPage={gotoPage}\n      />\n      <pre>\n        <code>\n          {JSON.stringify(\n            {\n              pageIndex,\n              pageSize,\n              pageCount,\n              canNextPage,\n              canPreviousPage,\n              sortBy,\n              groupBy,\n              expanded: expanded,\n              filters,\n              selectedRowIds: selectedRowIds,\n            },\n            null,\n            2\n          )}\n        </code>\n      </pre>\n    </div>\n  );\n}\n\n// Define a custom filter filter function!\nfunction filterGreaterThan(rows, id, filterValue) {\n  return rows.filter((row) => {\n    const rowValue = row.values[id];\n    return rowValue >= filterValue;\n  });\n}\n\n// This is an autoRemove method on the filter function that\n// when given the new filter value and returns true, the filter\n// will be automatically removed. Normally this is just an undefined\n// check, but here, we want to remove the filter if it's not a number\nfilterGreaterThan.autoRemove = (val) => typeof val !== \"number\";\n\n// This is a custom aggregator that\n// takes in an array of leaf values and\n// returns the rounded median\nfunction roundedMedian(leafValues) {\n  let min = leafValues[0] || 0;\n  let max = leafValues[0] || 0;\n\n  leafValues.forEach((value) => {\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n  });\n\n  return Math.round((min + max) / 2);\n}\n\nconst tableCols = [\n  {\n    Header: \"Id\",\n    accessor: \"id\",\n  },\n  {\n    Header: \"Name\",\n    accessor: \"name\",\n  },\n\n  {\n    Header: \"Prop1\",\n    accessor: \"prop1\",\n    Filter: NumberRangeColumnFilter,\n    filter: \"between\",\n  },\n\n  {\n    Header: \"Prop2 & Prop3\",\n    columns: [\n      {\n        Header: \"Prop2\",\n        accessor: \"prop2\",\n      },\n      {\n        Header: \"Prop3\",\n        accessor: \"prop3\",\n        Filter: SelectColumnFilter,\n        filter: \"includes\",\n      },\n    ],\n  },\n];\n\nfunction App() {\n  const columns = React.useMemo(() => tableCols, []);\n  const filterTypes = React.useMemo(customFilterTypes, []);\n  const defaultColumn = React.useMemo(defaultColumnConfig, []);\n\n  console.log({ tableData });\n  const [data, setData] = React.useState(() => tableData);\n  const [originalData] = React.useState(data);\n\n  // We need to keep the table from resetting the pageIndex when we\n  // Update data. So we can keep track of that flag with a ref.\n  const skipResetRef = React.useRef(false);\n\n  // When our cell renderer calls updateMyData, we'll use\n  // the rowIndex, columnId and new value to update the\n  // original data\n  const updateMyData = (rowIndex, columnId, value) => {\n    // We also turn on the flag to not reset the page\n    skipResetRef.current = true;\n    setData((old) =>\n      old.map((row, index) => {\n        if (index === rowIndex) {\n          return {\n            ...row,\n            [columnId]: value,\n          };\n        }\n        return row;\n      })\n    );\n  };\n\n  // After data changes, we turn the flag back off\n  // so that if data actually changes when we're not\n  // editing it, the page is reset\n  React.useEffect(() => {\n    skipResetRef.current = false;\n  }, [data]);\n\n  // Let's add a data resetter/randomizer to help\n  // illustrate that flow...\n  const resetData = () => {\n    // Don't reset the page when we do this\n    skipResetRef.current = true;\n    setData(originalData);\n  };\n\n  return (\n    <Styles>\n      <button onClick={resetData}>Reset Data</button>\n      <Table\n        columns={columns}\n        data={data}\n        updateMyData={updateMyData}\n        skipReset={skipResetRef.current}\n        filterTypes={filterTypes}\n        defaultColumn={defaultColumn}\n      />\n    </Styles>\n  );\n}\n\nexport default App;\n","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/Styles.js",["106"],"import React from \"react\";\nimport styled from \"styled-components\";\nconst Styles = styled.div`\n  padding: 1rem;\n\n  table {\n    border-spacing: 0;\n    border: 1px solid black;\n\n    tr {\n      :last-child {\n        td {\n          border-bottom: 0;\n        }\n      }\n    }\n\n    th,\n    td {\n      margin: 0;\n      padding: 0.5rem;\n      border-bottom: 1px solid black;\n      border-right: 1px solid black;\n\n      :last-child {\n        border-right: 0;\n      }\n    }\n\n    td {\n      input {\n        font-size: 1rem;\n        padding: 0;\n        margin: 0;\n        border: 0;\n      }\n    }\n  }\n\n  .search {\n    width: 300px;\n    padding: 10px;\n    margin-top: 10px;\n    margin-bottom: 10px;\n  }\n  .pagination {\n    padding: 0.5rem;\n  }\n`;\n\nexport default Styles;\n","/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/GlobalSearchFilter.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/ResearchTable.js",["107","108"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/data.js",["109"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/StockApp.js",["110","111"],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/components/Pagination.js",[],"/Users/jag/jag/JUNIVERSE/GIT/JAG-FRONTEND/JAG-REACT/jag-react-table-example/src/stocks/utils.js",["112"],"import { get, toNumber } from \"lodash-es\";\n\nexport function _getHistoryKey() {\n  const dt = new Date();\n  const yr = dt.getFullYear();\n  const month = dt.getMonth() + 1;\n  return `${yr}-${month}`;\n}\n\n// function get(stock, src, key) {\n//   // check: fetchStatus: \"COMPLETED\"\n//   //   return stock[src] ? stock[src][hisKey] && stock[src][hisKey][key] : null;\n//   return get(stock, `${src}.${hisKey}.${key}`, null);\n// }\n\nexport function getStockTableData(apiData) {\n  const hisKey = _getHistoryKey();\n  return apiData.map((stock, idx) => {\n    const rhgFairVal = get(stock, [\"rhg\", hisKey, \"fair_value\", \"value\"]);\n    return {\n      stockId: stock.stockId,\n      name: stock.name,\n      yfDivYield: get(stock, [\"yf\", hisKey, \"dividendYield\"]),\n      yfNOfAnalysts: get(stock, [\"yf\", hisKey, \"numberOfAnalystOpinions\"]),\n      yfRating: get(stock, [\"yf\", hisKey, \"rating\"]),\n      rhNOfAnalysts: get(stock, [\"rh\", hisKey, \"nOfAnalysts\"]),\n      rhBuy: get(stock, [\"rh\", hisKey, \"buy\"]),\n      rhHold: get(stock, [\"rh\", hisKey, \"hold\"]),\n      rhSell: get(stock, [\"rh\", hisKey, \"sell\"]),\n      rhgStarRating: get(stock, [\"rhg\", hisKey, \"star_rating\"]),\n      rhgStewardship: get(stock, [\"rhg\", hisKey, \"stewardship\"]),\n      rhgUncertainty: get(stock, [\"rhg\", hisKey, \"uncertainty\"]),\n      rhgFairVal: rhgFairVal ? Number(rhgFairVal) : null,\n    };\n  });\n}\n",{"ruleId":"113","replacedBy":"114"},{"ruleId":"115","replacedBy":"116"},{"ruleId":"113","replacedBy":"117"},{"ruleId":"115","replacedBy":"118"},{"ruleId":"119","severity":1,"message":"120","line":12,"column":21,"nodeType":"121","messageId":"122","endLine":12,"endColumn":31},{"ruleId":"119","severity":1,"message":"123","line":180,"column":10,"nodeType":"121","messageId":"122","endLine":180,"endColumn":23},{"ruleId":"113","replacedBy":"124"},{"ruleId":"115","replacedBy":"125"},{"ruleId":"119","severity":1,"message":"126","line":2,"column":8,"nodeType":"121","messageId":"122","endLine":2,"endColumn":12},{"ruleId":"119","severity":1,"message":"127","line":5,"column":8,"nodeType":"121","messageId":"122","endLine":5,"endColumn":17},{"ruleId":"119","severity":1,"message":"128","line":6,"column":8,"nodeType":"121","messageId":"122","endLine":6,"endColumn":17},{"ruleId":"119","severity":1,"message":"129","line":7,"column":8,"nodeType":"121","messageId":"122","endLine":7,"endColumn":17},{"ruleId":"119","severity":1,"message":"130","line":8,"column":8,"nodeType":"121","messageId":"122","endLine":8,"endColumn":17},{"ruleId":"113","replacedBy":"131"},{"ruleId":"115","replacedBy":"132"},{"ruleId":"119","severity":1,"message":"133","line":1,"column":8,"nodeType":"121","messageId":"122","endLine":1,"endColumn":13},{"ruleId":"119","severity":1,"message":"123","line":214,"column":10,"nodeType":"121","messageId":"122","endLine":214,"endColumn":23},{"ruleId":"119","severity":1,"message":"123","line":214,"column":10,"nodeType":"121","messageId":"122","endLine":214,"endColumn":23},{"ruleId":"119","severity":1,"message":"123","line":225,"column":10,"nodeType":"121","messageId":"122","endLine":225,"endColumn":23},{"ruleId":"119","severity":1,"message":"133","line":1,"column":8,"nodeType":"121","messageId":"122","endLine":1,"endColumn":13},{"ruleId":"119","severity":1,"message":"134","line":14,"column":10,"nodeType":"121","messageId":"122","endLine":14,"endColumn":19},{"ruleId":"119","severity":1,"message":"123","line":232,"column":10,"nodeType":"121","messageId":"122","endLine":232,"endColumn":23},{"ruleId":"119","severity":1,"message":"135","line":1,"column":15,"nodeType":"121","messageId":"122","endLine":1,"endColumn":23},{"ruleId":"136","severity":2,"message":"137","line":17,"column":5,"nodeType":"138","messageId":"139","endLine":17,"endColumn":54},{"ruleId":"140","severity":1,"message":"141","line":17,"column":42,"nodeType":"142","messageId":"143","endLine":17,"endColumn":43},{"ruleId":"119","severity":1,"message":"135","line":1,"column":15,"nodeType":"121","messageId":"122","endLine":1,"endColumn":23},"no-native-reassign",["144"],"no-negated-in-lhs",["145"],["144"],["145"],"no-unused-vars","'tableData1' is defined but never used.","Identifier","unusedVar","'roundedMedian' is defined but never used.",["144"],["145"],"'logo' is defined but never used.","'JagTable1' is defined but never used.","'JagTable2' is defined but never used.","'JagTable3' is defined but never used.","'JagTable4' is defined but never used.",["144"],["145"],"'React' is defined but never used.","'tableData' is defined but never used.","'toNumber' is defined but never used.","no-unused-expressions","Expected an assignment or function call and instead saw an expression.","ExpressionStatement","unusedExpression","no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression","no-global-assign","no-unsafe-negation"]